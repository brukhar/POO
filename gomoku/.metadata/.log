!SESSION 2018-11-22 18:51:37.391 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_181
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.core 2 0 2018-11-22 18:52:12.286
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Unknown Source)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4567)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.egit.ui 2 0 2018-11-22 18:52:33.528
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\guigu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 0 2018-11-22 18:53:52.098
!MESSAGE Could not import project located at D:\Mes Documents\Cours Chicoutimi\POO\ca\uqac\gomoku
!STACK 0
org.eclipse.ui.internal.wizards.datatransfer.CouldNotImportProjectException: Could not import project located at D:\Mes Documents\Cours Chicoutimi\POO\ca\uqac\gomoku
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.toExistingOrNewProject(SmartImportJob.java:568)
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.run(SmartImportJob.java:252)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:60)
Caused by: org.eclipse.core.internal.resources.ResourceException: Invalid project description.
	at org.eclipse.core.internal.resources.Project.checkDescription(Project.java:170)
	at org.eclipse.core.internal.resources.Project.assertCreateRequirements(Project.java:54)
	at org.eclipse.core.internal.resources.Project.create(Project.java:264)
	at org.eclipse.core.internal.resources.Project.create(Project.java:248)
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.createOrImportProject(SmartImportJob.java:607)
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.toExistingOrNewProject(SmartImportJob.java:555)
	... 2 more

!ENTRY org.eclipse.ui.ide 4 0 2018-11-22 18:54:15.764
!MESSAGE Could not import project located at D:\Mes Documents\Cours Chicoutimi\POO\ca\uqac
!STACK 0
org.eclipse.ui.internal.wizards.datatransfer.CouldNotImportProjectException: Could not import project located at D:\Mes Documents\Cours Chicoutimi\POO\ca\uqac
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.toExistingOrNewProject(SmartImportJob.java:568)
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.run(SmartImportJob.java:252)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:60)
Caused by: org.eclipse.core.internal.resources.ResourceException: Invalid project description.
	at org.eclipse.core.internal.resources.Project.checkDescription(Project.java:170)
	at org.eclipse.core.internal.resources.Project.assertCreateRequirements(Project.java:54)
	at org.eclipse.core.internal.resources.Project.create(Project.java:264)
	at org.eclipse.core.internal.resources.Project.create(Project.java:248)
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.createOrImportProject(SmartImportJob.java:607)
	at org.eclipse.ui.internal.wizards.datatransfer.SmartImportJob.toExistingOrNewProject(SmartImportJob.java:555)
	... 2 more
!SESSION 2018-11-22 19:32:54.160 -----------------------------------------------
eclipse.buildId=4.8.0.I20180611-0500
java.version=1.8.0_181
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.core 2 0 2018-11-22 19:34:04.764
!MESSAGE Builtin LFS support not present/detected
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jgit.lfs.BuiltinLFS cannot be found by org.eclipse.egit.core_5.0.0.201806131550-r
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:508)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Unknown Source)
	at org.eclipse.egit.core.Activator.registerBuiltinLFS(Activator.java:279)
	at org.eclipse.egit.core.Activator.start(Activator.java:212)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:454)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.egit.ui.Activator$RepositoryChangeScanner.<init>(Activator.java:921)
	at org.eclipse.egit.ui.Activator.setupRepoChangeScanner(Activator.java:1034)
	at org.eclipse.egit.ui.Activator.start(Activator.java:336)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:779)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:772)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:729)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1002)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:354)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:468)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:114)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:505)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:328)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:392)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:470)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:411)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:150)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:609)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:177)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:931)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:60)
	at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:174)
	at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:104)
	at org.eclipse.ui.internal.Workbench$34.runWithException(Workbench.java:2378)
	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:233)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:144)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4567)
	at org.eclipse.ui.internal.StartupThreading.runWithoutExceptions(StartupThreading.java:95)
	at org.eclipse.ui.internal.Workbench.initializeDefaultServices(Workbench.java:2373)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:1654)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2859)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:654)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.egit.ui 2 0 2018-11-22 19:34:41.344
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\guigu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jface.text 4 0 2018-11-22 19:46:09.368
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException: org.eclipse.ajdt.core.javaelements.PointcutElementInfo cannot be cast to org.eclipse.jdt.internal.core.SourceMethodInfo
	at org.eclipse.ajdt.core.javaelements.AspectJMemberElement.getDefaultValue(AspectJMemberElement.java:324)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotationMemberDefaultValue(JavadocHover.java:854)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:830)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:752)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:675)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:667)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jface.text 4 2 2018-11-22 20:24:40.952
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface.text".
!STACK 0
java.lang.NullPointerException
	at java.util.Objects.requireNonNull(Unknown Source)
	at java.util.Arrays$ArrayList.<init>(Unknown Source)
	at java.util.Arrays.asList(Unknown Source)
	at org.eclipse.jface.text.contentassist.ContentAssistant$4.lambda$0(ContentAssistant.java:2050)
	at java.util.Collections$SingletonSet.forEach(Unknown Source)
	at org.eclipse.jface.text.contentassist.ContentAssistant$4.run(ContentAssistant.java:2049)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeContextInformation(ContentAssistant.java:2046)
	at org.eclipse.jface.text.contentassist.ContentAssistSubjectControlAdapter.computeContextInformation(ContentAssistSubjectControlAdapter.java:376)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup.computeContextInformation(ContextInformationPopup.java:403)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup.access$1(ContextInformationPopup.java:402)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup$1.run(ContextInformationPopup.java:189)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:71)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup.showContextProposals(ContextInformationPopup.java:183)
	at org.eclipse.jface.text.contentassist.ContentAssistant.showContextInformation(ContentAssistant.java:1879)
	at org.eclipse.recommenders.internal.snipmatch.rcp.completion.SnipmatchCompletionEngine$6.modifyText(SnipmatchCompletionEngine.java:253)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:180)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4118)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1076)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:775)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7371)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8227)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2499)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6011)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6042)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5740)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4118)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1076)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1099)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1486)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:350)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4765)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:345)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4757)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2303)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3532)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1170)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1059)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:153)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:667)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.jface.text 4 0 2018-11-22 20:24:40.961
!MESSAGE Error computing context information.
!STACK 0
java.lang.NullPointerException
	at java.util.Objects.requireNonNull(Unknown Source)
	at java.util.Arrays$ArrayList.<init>(Unknown Source)
	at java.util.Arrays.asList(Unknown Source)
	at org.eclipse.jface.text.contentassist.ContentAssistant$4.lambda$0(ContentAssistant.java:2050)
	at java.util.Collections$SingletonSet.forEach(Unknown Source)
	at org.eclipse.jface.text.contentassist.ContentAssistant$4.run(ContentAssistant.java:2049)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeContextInformation(ContentAssistant.java:2046)
	at org.eclipse.jface.text.contentassist.ContentAssistSubjectControlAdapter.computeContextInformation(ContentAssistSubjectControlAdapter.java:376)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup.computeContextInformation(ContextInformationPopup.java:403)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup.access$1(ContextInformationPopup.java:402)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup$1.run(ContextInformationPopup.java:189)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:71)
	at org.eclipse.jface.text.contentassist.ContextInformationPopup.showContextProposals(ContextInformationPopup.java:183)
	at org.eclipse.jface.text.contentassist.ContentAssistant.showContextInformation(ContentAssistant.java:1879)
	at org.eclipse.recommenders.internal.snipmatch.rcp.completion.SnipmatchCompletionEngine$6.modifyText(SnipmatchCompletionEngine.java:253)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:180)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4118)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1076)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:775)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7371)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8227)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2499)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6011)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6042)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5740)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:86)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4118)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1076)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1099)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1486)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:350)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4765)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:345)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4757)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2303)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3532)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1170)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1059)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:153)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:667)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:597)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:656)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:592)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1498)

!ENTRY org.eclipse.jface.text 4 0 2018-11-22 20:36:31.217
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException: org.eclipse.ajdt.core.javaelements.PointcutElementInfo cannot be cast to org.eclipse.jdt.internal.core.SourceMethodInfo
	at org.eclipse.ajdt.core.javaelements.AspectJMemberElement.getDefaultValue(AspectJMemberElement.java:324)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotationMemberDefaultValue(JavadocHover.java:854)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:830)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:752)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:675)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:667)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 1005 2018-11-22 20:50:37.003
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2018-11-22 20:50:37.016
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2018-11-22 20:50:37.017
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2018-11-22 20:50:37.018
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2018-11-22 20:50:37.041
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2018-11-22 20:50:37.041
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if()
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.core 4 1005 2018-11-22 20:50:43.078
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2018-11-22 20:50:43.103
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2018-11-22 20:50:43.104
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2018-11-22 20:50:43.104
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2018-11-22 20:50:43.138
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2018-11-22 20:50:43.139
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import ca.uqac.gomoku.core.model.Spot;

public interface GridEventListener {
	void stonePlaced(Spot place);
	void gameOver(Player winner);
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package ca.uqac.gomoku.aspects;

import java.util.List;

import javax.swing.JOptionPane;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Spot;
import ca.uqac.gomoku.core.model.Grid;

public aspect FinJeu {
	
	boolean ended = false;
	List<Spot> winningStones;

	pointcut gameFinished(Player winner) : execution(void gameOver(Player)) && args(winner);
	
	pointcut playing() : call(void placeStone(int, int, Player));
	
	pointcut winningStonesChange(List<Spot> newWinningStones) : set(List<Spot> Grid.winningStones)  && args(newWinningStones);
	
	after(List<Spot> newWinningStones) : winningStonesChange(newWinningStones) {
		winningStones = newWinningStones;
		if(winningStones.)
		Method setOccupant = Spot.class.getDeclaredMethod("setOccupant", Player.class);
	}
	
	after(Player winner) : gameFinished(winner) {
		ended = true;
		new Thread(()-> { 
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				JOptionPane.showMessageDialog(null, "bingoooo! the " + winner.getName() + " wins", "Fin de la partie", JOptionPane.INFORMATION_MESSAGE);
			}).start();
		
	}
	
	void around() : playing() {
		if(!ended)
		{
			proceed();
		}
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core;

import javafx.scene.paint.Color;

public class Player {

	private Color color;
	private final String name;

	public Player(String name, Color color) {
		this.name = name;
		this.color = color;
	}

	public Color getColor() {
		return color;
	}
	public String getName() {
		return name;
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.core.model;

import java.util.ArrayList;
import java.util.List;

import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;

public class Grid {
	static private int DEFAULT_BOARD_SIZE = 15;
	private int size;

	private final List<Spot> spotLst;
	private List<Spot> winningStones = new ArrayList<>(0);

	private final List<GridEventListener> listeners;

	public Grid() {
		this(DEFAULT_BOARD_SIZE);
	}
	public Grid(int size) {
		this.size = size;
		listeners = new ArrayList<>();
		spotLst = new ArrayList<>(size * size);
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				spotLst.add(new Spot(x, y));
			}
		}
	}

	/** Clear this board by removing all its stones. */
	public void clear() {
		winningStones.clear();
		spotLst.forEach(p -> p.clear());
		notifyStonePlaced(null);
	}

	public int getSize() {
		return size;
	}

	public boolean isFull() {
		return spotLst.stream().allMatch(p -> !p.isEmpty());
	}

	public boolean isGameOver() {
		return winningStones.size() > 0 || isFull();
	}

	public boolean isEmpty(int x, int y) {
		return getSpot(x, y).isEmpty();
	}

	public boolean isOccupiedBy(int x, int y, Player player) {
		return getSpot(x, y).isOccupant(player);
	}

	/** Return the specified place or null if it doesn't exist. */
	public Spot getSpot(int x, int y) {
		return spotLst.stream().filter(p -> p.x == x && p.y == y).findAny()
				.get();
	}

	/** Return the places of this board. */
	public Iterable<Spot> getSpots() {
		return spotLst;
	}

	public void placeStone(int x, int y, Player player) {
		Spot place = getSpot(x, y);
		if (place != null) {
			place.setOccupant(player);
			notifyStonePlaced(place);
			if (isWonBy(player)) {
				notifyGameOver(player); // win
			} else if (isFull()) {
				notifyGameOver(null); // tie
			}
		}
	}

	/**
	 * Return true if the given player has a winning row containing the
	 * specified place in the specified direction, where a direction is
	 * represented as:
	 * <ul>
	 * <li>horizontal: dx = 1, dy = 0</li>
	 * <li>vertical: dx = 0, dy = 1</li>
	 * <li>diagonal (\): dx = 1, dy = 1</li>
	 * <li>diagonal (/): dx = 1, dy = -1</li>
	 * </ul>
	 */
	private boolean isWonBy(int x, int y, int dx, int dy, Player player) {
		// consecutive places occupied by the given player
		final List<Spot> row = new ArrayList<>(5);

		// check left/lower side of (x,y)
		int sx = x; // starting x and y
		int sy = y; // i.e., (sx, sy) <----- (x,y)
		while (!(dx > 0 && sx < 0) && !(dx < 0 && sx >= size)
				&& !(dy > 0 && sy < 0) && !(dy < 0 && sy >= size)
				&& isOccupiedBy(sx, sy, player) && row.size() < 5) {
			row.add(getSpot(sx, sy));
			sx -= dx;
			sy -= dy;
		}

		// check right/higher side of (x,y)
		int ex = x + dx; // ending x and y
		int ey = y + dy; // i.e., (x,y) -----> (ex, ey)
		while (!(dx > 0 && ex >= size) && !(dx < 0 && ex < 0)
				&& !(dy > 0 && ey >= size) && !(dy < 0 && ey < 0)
				&& isOccupiedBy(ex, ey, player) && row.size() < 5) {
			row.add(getSpot(ex, ey));
			ex += dx;
			ey += dy;
		}

		if (row.size() >= 5) {
			winningStones = row;
		}
		return row.size() >= 5;
	}

	/** Return true if the given player has a winning row. */
	public boolean isWonBy(Player player) {
		return spotLst.stream().anyMatch(p -> isWonBy(p.x, p.y, 1, 0, player) // horizontal
				|| isWonBy(p.x, p.y, 0, 1, player) // vertical
				|| isWonBy(p.x, p.y, 1, 1, player) // diagonal(\)
				|| isWonBy(p.x, p.y, 1, -1, player)); // diagonal(/)
	}

	/** Register the given listener for board changes. */
	public void addGridEventstListener(GridEventListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}

	/** Unregister the given listener. */
	public void removeGridEventsListener(GridEventListener listener) {
		listeners.remove(listener);
	}

	/** Notify to registered listeners when a stone is placed. */
	private void notifyStonePlaced(Spot place) {
		listeners.forEach(l -> l.stonePlaced(place));
	}

	private void notifyGameOver(Player player) {
		listeners.forEach(l -> l.gameOver(player));
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.BoardEventListener;
import ca.uqac.gomoku.core.GridEventListener;
import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

public class Board extends Canvas {

	/** Number of pixels between horizontal/vertical lines of the board. */
	private final double spotSize = 30;
	private Grid boardModel;

	public Board(Grid b, BoardEventListener lstnr) {
		setWidth(spotSize * b.getSize());
		setHeight(spotSize * b.getSize());
		this.boardModel = b;
		b.addGridEventstListener(new GridEventListener() {
			@Override
			public void stonePlaced(Spot place) {
				drawStone(place);
			}
			@Override
			public void gameOver(Player winner) {
				System.out.println("bingoooo! the " + winner.getName() + " wins");
			}
		});

		this.addEventHandler(MouseEvent.MOUSE_CLICKED, e -> {
			Spot place = locateSpot((int) e.getX(), (int) e.getY());
			if (place != null && place.isEmpty()) {
				lstnr.spotClicked(place);
			}
		});
		drawGrid();
	}

	private void drawGrid() {
		GraphicsContext gc = this.getGraphicsContext2D();
		gc.setFill(Color.ANTIQUEWHITE);
		gc.setStroke(Color.BLACK);
		gc.setLineWidth(2);

		// number of v/h lines including boarder lines
		final int lines = boardModel.getSize() + 2;
		gc.fillRect(0, 0, spotSize * (lines - 1), spotSize * (lines - 1));

		double x = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(x, 0, x, spotSize * (lines - 1));
			x += spotSize;
		}

		double y = 0; // placeSize;
		for (int i = 0; i < lines; i++) {
			gc.strokeLine(0, y, spotSize * (lines - 1), y);
			y += spotSize;
		}
	}

	@SuppressWarnings("unused")
	private void drawStones() {
		boardModel.getSpots().forEach(s -> drawStone(s));
	}

	private void drawStone(Spot s) {
		if (!s.isEmpty()) {
			GraphicsContext gc = this.getGraphicsContext2D();
			gc.setFill((s.getOccupant()).getColor());
			double x = spotSize + s.x * spotSize; // center x
			double y = spotSize + s.y * spotSize; // center y
			double r = spotSize / 2; // radius
			gc.fillOval(x - r, y - r, r * 2, r * 2);
		}
	}

	private Spot locateSpot(double x, double y) {
		final double boardSize = boardModel.getSize();
		final double border = spotSize; // * 1;
		// recognize R pixels from an intersection
		final double R = spotSize / 2 - 2;

		// off board?
		if (x < border - R || y < border - R
				|| x > spotSize * (boardSize + 1) - (spotSize - R)
				|| y > spotSize * (boardSize + 1) - (spotSize - R)) {
			return null;
		}

		double px = 0;
		double dx = (x - border) % spotSize;
		if (dx <= R) {
			px = (x - border) / spotSize;
		} else if (dx >= spotSize - R) {
			px = (x - border) / spotSize + 1;
		} else {
			return null;
		}

		double py = 0;
		double dy = (y - border) % spotSize;
		if (dy <= R) {
			py = (y - border) / spotSize;
		} else if (dy >= spotSize - R) {
			py = (y - border) / spotSize + 1;
		} else {
			return null;
		}
		return boardModel.getSpot((int) px, (int) py);
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
/*
 * ----------------------------------------------------------------------------
 * "THE THE-WARE LICENSE":
 * Jebril A.R. wrote this bit of code.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy/make me a cup of Tea in return.
 * ----------------------------------------------------------------------------
 */
package ca.uqac.gomoku.ui;

import ca.uqac.gomoku.core.Player;
import ca.uqac.gomoku.core.model.Grid;
import ca.uqac.gomoku.core.model.Spot;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class App extends Application {

	private Grid gameGrid;
	private Player players[];
	int turn = 0;
	Canvas playGround;

	@Override
	public void init() throws Exception {
		super.init();
		players = new Player[]{new Player("Popeye", Color.GREEN),
								new Player("Brutus", Color.RED)};
		gameGrid = new Grid(15);
		playGround = new Board(this.gameGrid, this::makeMove);
	}

	@Override
	public void start(Stage primaryStage) {
		primaryStage.setTitle("Gomoku Game!");
		BorderPane root = new BorderPane();
		root.setCenter(playGround);
		primaryStage.setScene(new Scene(root));
		primaryStage.setResizable(false);
		primaryStage.show();
	}

	private void makeMove(Spot place) {
		gameGrid.placeStone(place.x, place.y, getCurrentPlayer());
	}

	private Player getCurrentPlayer() {
		turn++;
		return players[turn % 2];
	}

	public static void main(String[] args) {
		launch(args);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:733)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:799)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11672)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12310)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12612)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12598)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:365)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12718)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11739)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12025)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:897)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10705)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jface.text 4 0 2018-11-22 21:10:57.429
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException: org.eclipse.ajdt.core.javaelements.PointcutElementInfo cannot be cast to org.eclipse.jdt.internal.core.SourceMethodInfo
	at org.eclipse.ajdt.core.javaelements.AspectJMemberElement.getDefaultValue(AspectJMemberElement.java:324)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotationMemberDefaultValue(JavadocHover.java:854)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:830)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:752)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:675)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:667)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
